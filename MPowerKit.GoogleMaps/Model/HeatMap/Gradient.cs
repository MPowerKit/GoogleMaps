namespace MPowerKit.GoogleMaps;

public class Gradient
{
    /// <summary>
    /// Size of the color map for the heatmap.
    /// </summary>
    public int ColorMapSize { get; }

    /// <summary>
    /// The colors to be used in the gradient.
    /// </summary>
    public int[] Colors { get; }

    /// <summary>
    /// The starting point for each color, given as a percentage of the maximum intensity.
    /// </summary>
    public float[] StartPoints { get; }

    /// <summary>
    /// Creates a Gradient with the given colors, starting points, and color map size.
    /// </summary>
    /// <param name="colors">The colors to be used in the gradient.</param>
    /// <param name="startPoints">The starting point for each color, given as a percentage of the maximum intensity.</param>
    /// <param name="colorMapSize">The size of the color map to be generated by the Gradient.</param>
    public Gradient(Color[] colors, float[] startPoints, int colorMapSize = 250)
    {
        if (colors.Length != startPoints.Length)
            throw new ArgumentException("Colors and startPoints should be the same length.");
        if (colors.Length == 0)
            throw new ArgumentException("No colors have been defined.");
        for (var i = 1; i < startPoints.Length; i++)
        {
            if (startPoints[i] <= startPoints[i - 1])
                throw new ArgumentException("StartPoints should be in increasing order.");
        }

        ColorMapSize = colorMapSize;
        Colors = colors.Select(c => c.ToInt()).ToArray();
        StartPoints = startPoints;
    }

    protected virtual Dictionary<int, ColorInterval> GenerateColorIntervals()
    {
        Dictionary<int, ColorInterval> colorIntervals = [];

        // Create initial color if not already defined
        if (StartPoints[0] != 0f)
        {
            var initialColor = Colors[0].ColorWithNewAlpha(0f);
            colorIntervals[0] = new(initialColor, Colors[0], ColorMapSize * StartPoints[0]);
        }

        // Generate color intervals
        for (var i = 1; i < Colors.Length; i++)
        {
            var start = (int)(ColorMapSize * StartPoints[i - 1]);
            var duration = ColorMapSize * (StartPoints[i] - StartPoints[i - 1]);
            colorIntervals[start] = new(Colors[i - 1], Colors[i], duration);
        }

        var lastIndex = StartPoints.Length - 1;
        // Extend to the final color
        if (StartPoints[lastIndex] != 1f)
        {
            var start = (int)(ColorMapSize * StartPoints[lastIndex]);
            var duration = ColorMapSize * (1f - StartPoints[lastIndex]);
            colorIntervals[start] = new(Colors[lastIndex], Colors[lastIndex], duration);
        }

        return colorIntervals;
    }

    /// <summary>
    /// Generates the color map to use with a provided gradient.
    /// </summary>
    /// <param name="opacity">Overall opacity of the entire image: every individual alpha value will be multiplied by this opacity.</param>
    /// <returns>The generated color map based on the gradient.</returns>
    public virtual int[] GenerateColorMap(float opacity)
    {
        opacity = Math.Clamp(opacity, 0f, 1f);

        var colorIntervals = GenerateColorIntervals();
        Span<int> colorMap = stackalloc int[ColorMapSize];
        var interval = colorIntervals[0];
        var start = 0;

        for (var i = 0; i < ColorMapSize; i++)
        {
            if (colorIntervals.TryGetValue(i, out var newInterval))
            {
                interval = newInterval;
                start = i;
            }

            var ratio = (i - start) / interval.Duration;
            colorMap[i] = ColorExtensions.HsvColorsInterpolation(interval.Color1, interval.Color2, ratio);
        }

        if (opacity < 1f)
        {
            for (var i = 0; i < ColorMapSize; i++)
            {
                colorMap[i] = colorMap[i].ColorWithMultipliedAlphas(opacity);
            }
        }

        return colorMap.ToArray();
    }
}

public record struct ColorInterval(int Color1, int Color2, float Duration);